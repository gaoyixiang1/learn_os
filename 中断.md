# 中断

# 一、前言

==中断的本质就是由外设打断CPU，即CPU获知了计算机中发生的某些事，让CPU暂停当前正在执行的任务去执行另外的任务，当该任务完成之后，CPU继续执行刚才的程序，整个过程就是中断处理==。中断是一个特殊的电信号，由硬件设备发送给处理器，当处理器收到中断后，会马上向操作系统反映此信号的到来，然后操作系统会负责处理这些新到来的数据。

<img src=".\img\interrupt_1.png" alt="image-20231130110720479" style="zoom: 50%;" />

在《真相还原》一书上，有这样一句话，我觉得挺有道理的。==“操作系统是一个死循环，这个死循环仅仅是保证操作系统能周而复始的运行下去，而运行的目的，就是为了等待某些事情的发生” 。==，所以操作系统是被中断驱动的，他一直重复运行，等待发生某些事情，这些事情以中断的形式通知操作系统。

中断的类型可以大概这样划分：

<img src=".\img\interrupt_2.png" alt="image-20231130153035350" style="zoom: 50%;" />

# 二、相关概念 

## 2.1 中断向量表 IVT

不同的设备对应的中断不同，而每个中断都通过唯一的标识符来标识哪个设备产生的中断，这个标识符就是中断向量号，CPU会根据接收到的中断号，可以知道是哪个设备发出了中断信号，并相应地调用相应的中断处理程序来处理中断事件。

intel x86共支持256种中断，即对应的中断向量号为0-255，所有256种中断的分配如下： 

| 中断向量号 |  对应的中断类型  |
| :--------: | :--------------: |
|    0-31    | 异常和非屏蔽中断 |
|   32-47    |     屏蔽中断     |
|   48-255   |      软中断      |

中断向量表一共有256*4B =1KB个字节，每个表项大小为4B，都包含一个中断或异常的处理程序的地址。当系统发生中断或异常时，处理器会查找相应中断向量表的表项，以找到正确的处理程序的入口地址。

## 2.2 中断描述符表 IDT

 在保护模式下，用于存储中断处理程序的入口地址的表为中断描述符表，当CPU接收到一个中断请求，需要用中断向量在中断描述符表中查找对应的描述符，再去该描述符种找到中断处理程序的起始地址，然后执行中断处理程序。

中断描述符表里面有中断门描述符、系统门描述符和陷阱门描述符。所有描述符大小都是8B。关于这些门描述符的格式如下图：

<img src=".\img\interrupt_3.png" alt="image-20231130160302592" style="zoom:67%;" />

一个中断源就会产生一个中断向量，每个中断向量都对应中断描述符表中的一个门描述符，任何中断源都通过中断向量对应到中断描述符表中的门描述符，通过该门描述符就找到了对应的中断处理程序。 

## 2.3 中断控制器

中断控制器，相当是一个中介，负责管理来自外设的中断，当中断控制器收到了中断之后，会进行中断判优，并将优先级高的中断转发给CPU进行处理。

<img src=".\img\interrupt_4.png" alt="image-20231130160302592" style="zoom:67%;" />

在x86架构下通过`cat /proc/interrupts`命令可查看当前系统支持的外设中断信息

<img src=".\img\interrupt_5.png" alt="image-20231130160302592" style="zoom:67%;" />

分别表示 中断号、在CPU0和CPU1上发生的中断处理次数、中断类型以及触发方式，触发中断的事件。

在arm架构下通过`cat /proc/interrupts`命令可查看当前系统支持的外设中断信息

<img src=".\img\interrupt_6.png" alt="image-20231130160302592" style="zoom:67%;" />

分别表示Linux分配的中断号、在CPU上发生中断的次数、设备的硬件中断、硬件中断号、触发方式、设备名称。

# 三、相关数据结构分析

## 3.1 request_irq()

中断描述符表IDT初始化后， 必须通过 `request_irq()` 函数将相应的中断服务例程 挂入中断请求队列，即对其 进行注册，其中，参数中的中断服务例程`handler`被挂入中断请求列表中

```c
static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
    
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);//通过 调用 request_threaded_irq 函数，传递 NULL 作为线程函数。
}
```

`request_irq`函数的参数分别是中断号，中断处理函数以及中断处理标志，中断名和设备`id`。下面是`request_irq`的各个参数介绍：

-  第一个参数 irq 是中断号，对应的是中断线的编号，可以使用命令` cat /proc/interrupts `查到；

-  第二个参数 handler 是中断服务例程，中断发生时，系统调用这个函数，是可以自定义的处理程序；

-  第三个参数` flags` 是标志位，指定了这个中断处理的属性，有以下的参数可以设置：

  ```c
  #define IRQF_SHARED 0 //表示多个设备共享中断线，在同一条共享中断线上注册的每个处理程序都必须设定这个标志
  
  #define IRQF_DISABLED //意味着内核在处理中断处理程序期间，要禁止所有的其他中断
  
  #define IRQF_TIMER //该标志是特别为系统定时器的中断处理做准备的
  
  #define IRQF_SAMPLE_RANDOM //此标志表明这个设备产生的中断对内核entropy pool有贡献
  
  ```

- 第四个参数 name 是中断程序的名字，使用命令 `cat /proc/interrupts` 可以查看中断程序名字；

- 最后一个参数 `dev` 主要用于共享中断线，一般设置为这个设备的设备结构体或者 NULL

下面是`request_irq`主要调用的函数`request_threaded_irq`

```c
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id)
{
	struct irqaction *action;
	struct irq_desc *desc;
	int retval;
	//检查是否未连接
	if (irq == IRQ_NOTCONNECTED)
		return -ENOTCONN;

	/*
	 * Sanity-check: shared interrupts must pass in a real dev-ID,
	 * otherwise we'll have trouble later trying to figure out
	 * which interrupt is which (messes up the interrupt freeing
	 * logic etc).
	 *
	 * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and
	 * it cannot be set along with IRQF_NO_SUSPEND.
	 */
    //检查中断的标志是否合法
	if (((irqflags & IRQF_SHARED) && !dev_id) ||
	    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||
	    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))
		return -EINVAL;

	desc = irq_to_desc(irq);//通过调用irq_to_desc函数，再从irq_desc数组中申请一个desc
	if (!desc)
		return -EINVAL;
	// 检查中断是否可请求
	if (!irq_settings_can_request(desc) ||
	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))
		return -EINVAL;
	// 在没有主处理函数的情况下，也没有线程函数，则出错，如果有线程函数，则使用默认的主处理函数
	if (!handler) {
		if (!thread_fn)
			return -EINVAL;
		handler = irq_default_primary_handler;
	}
	//分配大小为sizeof(struct irqaction)的空间
	action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);
	if (!action)
		return -ENOMEM;
	//申请空间成功，则赋初始值，设置action的各个字段
	action->handler = handler;
	action->thread_fn = thread_fn;
	action->flags = irqflags;
	action->name = devname;
	action->dev_id = dev_id;
	//获取中断的引用计数
	retval = irq_chip_pm_get(&desc->irq_data);
	if (retval < 0) {
		kfree(action);
		return retval;
	}
    //调用__setup_irq函数把action添加到desc上的action链表里
	retval = __setup_irq(irq, desc, action);
	//请求失败，释放对应的资源
	if (retval) {
		irq_chip_pm_put(&desc->irq_data);
		kfree(action->secondary);
		kfree(action);
	}

	...
	return retval;
}
```

此函数的流程图如图所示

​						<img src=".\img\interrupt_7.png" alt="image-20231130160302592" style="zoom:67%;" />	 

注册一个中断后，可以通过`cat /proc/interrupts`来查看相应的中断信息。

## 3.2 struct irq_desc

```c
struct irq_desc {
    struct irq_common_data  irq_common_data;      // 通用的中断数据，包含中断控制和处理的基本信息
    struct irq_data         irq_data;             // 具体中断的数据结构，包含中断号等信息
    unsigned int __percpu   *kstat_irqs;          // 指向统计信息的指针
    irq_flow_handler_t      handle_irq;           //指向中断函数, 中断产生后，就会执行这个handle_irq
#ifdef CONFIG_IRQ_PREFLOW_FASTEOI
    irq_preflow_handler_t   preflow_handler;      // 如果启用 PREFLOW_FASTEOI，则包含预处理中断的函数
#endif
    struct irqaction       *action;               // action链表，包含注册的回调函数等
    unsigned int            status_use_accessors; // 标志，指示是否使用访问器函数来设置和获取状态
    unsigned int            core_internal_state__do_not_mess_with_it; 
    
   ...
       
       
       
    struct mutex            request_mutex;         // 中断请求互斥锁
    int                     parent_irq;            // 父中断号
    struct module           *owner;                // 持有中断的内核模块
    const char              *name;                 // 中断的名称
} ____cacheline_internodealigned_in_smp; 

```



驱动程序通过request_irq()注册中断处理程序，并且激活给定的中断线，以处理中断。通过上面的分析，我们了解到request_irq最终把设置好的irqaction链接到irq_desc中的action链表中。当中断发生时，内核会遍历相应中断描述符的 `action` 链表，依次调用链表中每个 `struct irqaction` 中指定的处理函数，从而完成对中断的处理。

## 3.3 struct irq_chip

`struct irq_chip`这个数据结构是用来描述中断控制器的

```c
struct irq_chip {
	struct device	*parent_device;						//指向中断控制器父设备的指针
        const char	*name;									//中断控制器的名称
	unsigned int	(*irq_startup)(struct irq_data *data); //启动中断的回调函数
	void		(*irq_shutdown)(struct irq_data *data);//关闭中断的回调函数
	void		(*irq_enable)(struct irq_data *data);//启用中断的回调函数
	void		(*irq_disable)(struct irq_data *data);//禁用中断的回调函数

	void		(*irq_ack)(struct irq_data *data);//开始一个新的中断
	void		(*irq_mask)(struct irq_data *data);//屏蔽中断源
	void		(*irq_mask_ack)(struct irq_data *data);//开始一个新中断冰屏蔽中断源
	void		(*irq_unmask)(struct irq_data *data);//取消中断源的掩码
	void		(*irq_eoi)(struct irq_data *data);//中断结束

	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);//设置SMP机器的CPU亲和性
	int		(*irq_retrigger)(struct irq_data *data);				//重新发送中断的回调函数
	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type);//设置设置中断类型的回调函数
	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);

	...
        
	void		(*ipi_send_single)(struct irq_data *data, unsigned int cpu);
	void		(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);

	unsigned long	flags;						//中断控制器特定标志的标志字段
};
```

关于中断控制器和中断描述符之间的关系，如图所示：

<img src=".\img\interrupt_8.png" alt="image-20231130160302592" style="zoom:67%;" />

通过这些数据结构之间的关系，我们了解到在arm架构下，Linux分配的中断号和硬件中断号的映射关系

- 通过中断号获取到`irq_desc`的数据结构
- 由`irq_desc`得到`irq_data`，并在`irq_data`中设置中断号和硬件中断号，

# 四、 中断管理

内核把中断处理分为两部分：上半部和下半部。上半部就是中断服务程序能立即执行，而下半部就是一些内核函数推迟处理。下半部运行时是允许中断请求的，而上半部运行是允许中断的。下半部的机制主要有tasklet、workqueue等

## 4.1 tasklet机制

tasklet机制是利用软中断实现的一种下半部机制，运行在软中断上下文中。

### 4.1.1 tasklet结构

```c
struct tasklet_struct
{
	struct tasklet_struct *next;//指向tasklet链表中的下一个结构体
	unsigned long state;//tasklet的状态
	atomic_t count;//引用计数器
	void (*func)(unsigned long);//要调用的函数
	unsigned long data;//传递给函数的参数
};
```

- 当state == TASKLET_STATE_SCHED ，则表明tasklet已经被调度，正准备运行。 state == TASKLET_STATE_RUN，则表示tasklet正在运行中。

- count =0，则代表tasklet处于激活状态。否则count不为0，表示tasklet被禁止，不允许执行。
- func指针指向的函数就是下半部要推迟执行的函数，data是这个函数的参数 

### 4.1.2 声明和使用tasklet

要在驱动中使用tasklet机制，则首先要定义一个tasklet。定义的方式有两种

- 静态声明

  ```c
  #define DECLARE_TASKLET(name, func, data) \
  struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
  
  #define DECLARE_TASKLET_DISABLED(name, func, data) \
  struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
  ```

​	这两个宏都可以静态声明一个tasklet结构体，唯一的区别在于count成员的初始变量不一样，DECLARE_TASKLET中count的初始为0，表示tasklet被激活，而DECLARE_TASKLET_DISABLED中，将count=1，表示tasklet被关闭

- 动态声明

  调用tasklet_init()函数来动态初始化tasklet数据结构，对于传入的初值，把他们赋给tasklet_struct的各个字段

  ```c
  void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data)
  {
  	t->next = NULL;
  	t->state = 0;
  	atomic_set(&t->count, 0);
  	t->func = func;
  	t->data = data;
  }
  ```

### 4.1.3 调度tasklet

通过调用tasklet_schedule()函数并传递给这个函数一个相应的tasklet_struct指针，则该tasklet就会被调度，以便适当的时候执行

```c
static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))//如果t->state没有设置TASKLET_STATE_SCHED，即还没有被调度
		__tasklet_schedule(t);//通过调用__tasklet_schedule()来调度
}
```

**__tasklet_schedule的代码如下：**

```c
void __tasklet_schedule(struct tasklet_struct *t)
{
	__tasklet_schedule_common(t, &tasklet_vec,TASKLET_SOFTIRQ);
}
```

这里出现了`tasklet_vec`，通过查找相关资料，了解到每个CPU要维护两个`tasklet`链表，一个用于普通优先级的`tasklet_vec`，另一个用于高优先级的`tasklet_hi_vec`

```c
/*
 * Tasklets
 */

//tasklet_head 结构包含头指针，和指向尾指针的指针
struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};
//DEFINE_PER_CPU 宏用于定义每个 CPU 独立的数据结构
static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);//普通优先级
static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);//高优先级
```

**__tasklet_schedule_common代码如下：**

```c
static void __tasklet_schedule_common(struct tasklet_struct *t,struct tasklet_head __percpu *headp,
				      unsigned int softirq_nr)
{
	struct tasklet_head *head;
	unsigned long flags;

	local_irq_save(flags);// 禁用本地中断
	head = this_cpu_ptr(headp);//指向当前cpu的普通优先级链表的tasklet_head结构体，里面包含了*head 和 **tail
	t->next = NULL;
	*head->tail = t;//将这个中断添加到tasklet链表的尾部
	head->tail = &(t->next);//更新tasklet_head结构体中的tail指针
	raise_softirq_irqoff(softirq_nr);//触发相应的软中断
	local_irq_restore(flags);//恢复本地中断状态
}
```

### 4.1.4 删除tasklet

通过调用tasklet_kill来去掉一个tasklet，该函数的参数是指向某个tasklet的指针

```c
void tasklet_kill(struct tasklet_struct *t)
{
	if (in_interrupt())//检查是否在中断上下文中，在的话就打印尝试杀死任务的消息
		pr_notice("Attempt to kill tasklet from interrupt\n");

	while (test_and_set_bit(TASKLET_STATE_SCHED, &t->state)) {
		do {
			yield();//如果这个tasklet被调度，则一直执行空闲进程等待
		} while (test_bit(TASKLET_STATE_SCHED, &t->state));
	}
	tasklet_unlock_wait(t);//解锁
	clear_bit(TASKLET_STATE_SCHED, &t->state);//清楚tasklet的被调度的标志
}
```

## 4.2 workqueue机制

工作队列机制是另外一个常用的下半部机制，工作队列的基本原理是把work(需要推迟执行的函数)交由一个内核线程来执行，并且总是在进程上下文中执行。工作队列的优点是利用进程的上下文来执行中断的下半部操作，==因此工作队列允许重新调度和睡眠，是异步执行的进程上下文==

应用场景：当驱动程序或内核子系统在进程上下文中有异步执行的工作任务的时候，可与使用工作项来描述工作任务。把工作项添加到一个队列，然后由一个内核线程执行工作任务的回调函数。

### 4.2.1 工作

这里，我们把推后执行的任务称作`work`工作，描述工作的数据结构为`work_struct`。这些工作以队列的结构组织成工作队列，其数据结构为`workqueue_struct`，而工作者线程就是负责执行工作队列的工作，系统默认的工作者线程为events

```c
struct work_struct {
	atomic_long_t data;//函数的参数
	struct list_head entry;//工作的链表
	work_func_t func;//要执行的函数
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
};
```

这些工作被链接成链表，当一个工作线程被唤醒的话，它会执行它的链表上的所有工作，工作被执行完毕，它就将相应的work_struct对象从链表上移去，如果链表为空的话，则睡眠。

**如何创建退后的工作：**

- 通过DECLARE_WORK来静态创建该结构，`DECLARE_WORK(name,void(*func)(void *),void *data)`，含义为创建了一个名为name 的work，其待执行的函数为func，参数为data。
- 通INIT_WORK(struct work_struct *work，void(*func)(void *),void *data)动态的初始化一个由work指向的工作，其待执行的函数为func，参数为data。

**如何调度工作**

`schedule_work(&work)；`



### 4.2.2 工作队列

```c
struct workqueue_struct {
	struct list_head	pwqs;		/* WR: all pwqs of this wq */
	struct list_head	list;		/* PR: 所有工作队列的链表 */

	struct mutex		mutex;		/* 互斥锁 */
	int			work_color;	/* WQ: current work color */
	int			flush_color;	/* WQ: current flush color */
	atomic_t		nr_pwqs_to_flush; /* flush in progress */
	struct wq_flusher	*first_flusher;	/* WQ: first flusher */
	struct list_head	flusher_queue;	/* WQ: flush waiters */
	struct list_head	flusher_overflow; /* WQ: flush overflow list */

	struct list_head	maydays;	/* MD: pwqs requesting rescue */
	struct worker		*rescuer;	/* I: rescue worker */

	int			nr_drainers;	/* WQ: drain in progress */
	int			saved_max_active; /* WQ: 工作队列的最大活跃数 */

	struct workqueue_attrs	*unbound_attrs;	/* PW: only for unbound wqs */
	struct pool_workqueue	*dfl_pwq;	/* PW: only for unbound wqs */


	char			name[WQ_NAME_LEN]; /*  工作队列的名称 */

	/*
	 * Destruction of workqueue_struct is sched-RCU protected to allow
	 * walking the workqueues list without grabbing wq_pool_mutex.
	 * This is used to dump all workqueues from sysrq.
	 */
	struct rcu_head		rcu;// RCU 头

	/* hot fields used during command issue, aligned to cacheline */
	unsigned int		flags ____cacheline_aligned; /* WQ: WQ_* flags */
	struct pool_workqueue __percpu *cpu_pwqs; /* I: per-cpu pwqs */
	struct pool_workqueue __rcu *numa_pwq_tbl[]; /* PWR: unbound pwqs indexed by node */
};
```

### 4.2.3 创建工作队列

常见的创建工作队列的接口函数为`alloc_workqueue()`，它有3个参数，分别是`name`, `flags`和`max_active`。查看函数的代码如下：

```c
#ifdef CONFIG_LOCKDEP
#define alloc_workqueue(fmt, flags, max_active, args...)		\
({									\
	static struct lock_class_key __key;				\
	const char *__lock_name;					\
									\
	__lock_name = "(wq_completion)"#fmt#args;			\
									\
	__alloc_workqueue_key((fmt), (flags), (max_active),		\
			      &__key, __lock_name, ##args);		\
})
#else
#define alloc_workqueue(fmt, flags, max_active, args...)		\
	__alloc_workqueue_key((fmt), (flags), (max_active),		\
			      NULL, NULL, ##args)
#endif
```

可以看出来，最终会调用`__alloc_workqueue_key`函数来创建工作队列。

flags的值有以下几种：

- WQ_UNBOUND：工作任务会加入UNBOUND队列。
- WQ_FREEZABLE：会参与系统的挂起过程，会让工作线程在处理完所有的工作之后完成进程的冻结，直到进程被解冻，否则不会开始新的工作
- WQ_MEM_RECLAIM：当内存紧张的时候，创建工作线程可能会失败
- WQ_HIGHPRI：属于高优先级的线程池，拥有较低的nice值
- WQ_CPU_INTENSIVE：属于特别能消耗CPU资源的一类工作
- __WQ_ORDERED：表示在同一时间只能执行一个工作

### 4.2.4 使用工作队列

要使用系统默认的工作队列，首先需要初始化工作，初始化工作是通过`INIT_WORK()`宏来完成的。

```
#define INIT_WORK(_work, _func)						\
	__INIT_WORK((_work), (_func), 0)
```

其中`__INIT_WORK()`定义如下

```#define __INIT_WORK(_work, _func, _onstack)				\
#define __INIT_WORK(_work, _func, _onstack)				\
	do {								\
		__init_work((_work), _onstack);				\
		(_work)->data = (atomic_long_t) WORK_DATA_INIT();	\
		INIT_LIST_HEAD(&(_work)->entry);			\
		(_work)->func = (_func);				\
	} while (0)
```

初始化工作之后，就可以调用`schedule_work()`来把工作挂入系统默认的工作队列。

```c
/**
 * schedule_work - put work task in global workqueue
 * @work: job to be done
 *
 * Returns %false if @work was already on the kernel-global workqueue and
 * %true otherwise.
 *
 * This puts a job in the kernel-global workqueue if it was not already
 * queued and leaves it in the same position on the kernel-global
 * workqueue otherwise.
 */
static inline bool schedule_work(struct work_struct *work)
{
	return queue_work(system_wq, work);
}
```

## 五、实验

## 5.1 实验一、tasklet

### 5.1.1 实验内容

1）写一个简单的内核模块，初始化一个 tasklet，在 write()函数里调用该 tasklet 回

调函数，在 tasklet 回调函数中输出用户程序写入的字符串。

2）写一个应用程序，测试该功能。

### 5.1.2 代码实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/init.h>
#include <linux/miscdevice.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/kfifo.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/cdev.h>
#include <linux/poll.h>
#include <linux/interrupt.h>

#define DEMO_NAME "mydemo_dev"
#define MYDEMO_FIFO_SIZE 64
// 定义字符设备号和结构体
static dev_t dev;
static struct cdev *demo_cdev;
static struct class *mydemo_class;
// 定义设备结构体
struct mydemo_device {
	char name[64];//设备名
	struct device *dev;//设备指针
    wait_queue_head_t read_queue;//读等待队列
	wait_queue_head_t write_queue;//写等待队列
	struct kfifo mydemo_fifo;//FIFO缓冲区
	struct fasync_struct *fasync;
	struct mutex lock;//锁
};
// 设备的私有数据结构体，里面添加了tasklet
struct mydemo_private_data {
	struct mydemo_device *device;//设备指针，指向设备
	char name[64];	//设备名
	struct tasklet_struct tasklet;
};

#define MYDEMO_MAX_DEVICES  8 //最多支持8个设备
static struct mydemo_device *mydemo_device[MYDEMO_MAX_DEVICES]; 

//tasklet 的回调函数
static void do_tasklet(unsigned long data)
{
	struct mydemo_device *device = (struct mydemo_device *)data;//通过强制转换来确保device指向了设备结构体

	dev_info(device->dev, "%s: trigger a tasklet\n", __func__);//打印相关信息
}

//打开设备驱动的回调函数
static int demodrv_open(struct inode *inode, struct file *file)
{	unsigned int minor = iminor(inode);//次设备号
	struct mydemo_private_data *data;
	struct mydemo_device *device = mydemo_device[minor];//device指向了次设备号对应的设备

	dev_info(device->dev, "%s: major=%d, minor=%d, device=%s\n", __func__, 
			MAJOR(inode->i_rdev), MINOR(inode->i_rdev), device->name);//打印相关信息

	data = kmalloc(sizeof(struct mydemo_private_data), GFP_KERNEL);//为保存设备的私有数据申请空间
	if (!data)
		return -ENOMEM;

	sprintf(data->name, "private_data_%d", minor);
	tasklet_init(&data->tasklet, do_tasklet, (unsigned long)device);//通过tasklet_init来初始化该设备的私有数据中的tasklet
	// 将设备指针和私有数据指针关联
	data->device = device;
 	//将私有数据存储到file的private_data中
	file->private_data = data;

	return 0;
}

//释放设备驱动的回调函数
static int demodrv_release(struct inode *inode, struct file *file)
{
	struct mydemo_private_data *data = file->private_data;//data用来保存file结构的私有数据成员

	tasklet_kill(&data->tasklet);//调用tasklet_kill函数来关闭tasklet
	kfree(data);//释放空间
    
	return 0;
}

// 读取设备驱动的回调函数
static ssize_t
demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
   //file表示打开的设备文件，buf表示用户空间的内存起始地址,lbuf表示用户需要读取的字节数，ppos指向文件的位置
{
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备
	int actual_readed;//真实读取的字节数
	int ret;

	//如果设备驱动的KFIFO为空，且文件标志打开了非阻塞
	if (kfifo_is_empty(&device->mydemo_fifo)) {
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;
        
	//如果文件标志没有打开非阻塞，则让该进程进入睡眠，则打印睡眠进程的信息
		dev_info(device->dev, "%s:%s pid=%d, going to sleep, %s\n", __func__, device->name, current->pid, data->name);
        
        //使用wait_event_interruptible使得设备的读队列的队头元素进入可中断睡眠，直到环形缓冲区不为空
		ret = wait_event_interruptible(device->read_queue,!kfifo_is_empty(&device->mydemo_fifo));
		if (ret)
			return ret;
	}

	mutex_lock(&device->lock);//打开设备的互斥锁
    
    //读取数据这部分通过kfifo_to_user 函数将从KFIFO 中读取出count字节的数据复制到用户空间中去
	ret = kfifo_to_user(&device->mydemo_fifo, buf, count, &actual_readed);
	if (ret)
		return -EIO;
	tasklet_schedule(&data->tasklet);//如果环形缓冲区有数据，我们调用 tasklet_schedule()来触发设备的tasklet。
	mutex_unlock(&device->lock);//解锁
    
	//KFIFO有数据，则唤醒读队列中所有的可中断进程
	if (!kfifo_is_full(&device->mydemo_fifo)){
		wake_up_interruptible(&device->write_queue);
		kill_fasync(&device->fasync, SIGIO, POLL_OUT);
	}

	
	dev_info(device->dev, "%s:%s, pid=%d, actual_readed=%d, pos=%lld\n",__func__,
			device->name, current->pid, actual_readed, *ppos);//打印相关信息
	return actual_readed;
}

//写设备驱动的回调函数
static ssize_t
demodrv_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备

	unsigned int actual_write;
	int ret;
//如果环形缓冲区满了且文件标志打开了非阻塞标志
	if (kfifo_is_full(&device->mydemo_fifo)){
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;
//文件标志没有打开了非阻塞标志，则这个写操作进程进入睡眠状态
		dev_info(device->dev, "%s:%s pid=%d, going to sleep\n", __func__, device->name, current->pid);
		//使用wait_event_interruptible让设备的写队列的队头元素进入可中断睡眠，直到环形缓冲区不满
        ret = wait_event_interruptible(device->write_queue,
				!kfifo_is_full(&device->mydemo_fifo));
		if (ret)
			return ret;
	}

	mutex_lock(&device->lock);//打开设备的互斥锁
//kfifo _from user 函数将用户数据写入到 KFIFO 中，此时 actual_write 中保存的是实际写入成功的字节数
	ret = kfifo_from_user(&device->mydemo_fifo, buf, count, &actual_write);
	if (ret)
		return -EIO;
	mutex_unlock(&device->lock);//解锁
    
//如果环形缓冲区中有空可写，则调用wake_up_interruptible来唤醒设备的写队列中的可中断睡眠的进程
	if (!kfifo_is_empty(&device->mydemo_fifo)) {
		wake_up_interruptible(&device->read_queue);
		kill_fasync(&device->fasync, SIGIO, POLL_IN);
		printk("%s kill fasync\n", __func__);
	}

	dev_info(device->dev, "%s:%s pid=%d, actual_write =%d, ppos=%lld, ret=%d\n", __func__,
			device->name, current->pid, actual_write, *ppos, ret);//打印相关信息

	return actual_write;
}

static unsigned int demodrv_poll(struct file *file, poll_table *wait)
{
	int mask = 0;
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备

	mutex_lock(&device->lock);//打开设备的互斥锁
//poll_ wait()函数会把当前进程添加到指定的等待列表 
	poll_wait(file, &device->read_queue, wait);
    poll_wait(file, &device->write_queue, wait);
 //如果缓冲区不空，唤醒写进程
	if (!kfifo_is_empty(&device->mydemo_fifo))
		mask |= POLLIN | POLLRDNORM;
    //如果缓冲区不满，唤醒读进程
	if (!kfifo_is_full(&device->mydemo_fifo))
		mask |= POLLOUT | POLLWRNORM;

	mutex_unlock(&device->lock);//解锁
	
	return mask;
}

static int demodrv_fasync(int fd, struct file *file, int on)
{
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备

	int ret;

	mutex_lock(&device->lock);//打开设备的互斥锁

	dev_info(device->dev, "%s send SIGIO\n", __func__);//打印相关信息
	ret = fasync_helper(fd, file, on, &device->fasync); // 调用 fasync_helper 函数，处理异步通知
	mutex_unlock(&device->lock);//解锁

	return ret;
}

//定义了设备驱动的操作集
static const struct file_operations demodrv_fops = {
	.owner = THIS_MODULE,
	.open = demodrv_open,
	.release = demodrv_release,
	.read = demodrv_read,
	.write = demodrv_write,
     .poll = demodrv_poll,
	.fasync = demodrv_fasync,
};

//模块注册函数
static int __init simple_char_init(void)
{
	int ret;
	int i;
	struct mydemo_device *device;
	//通过alloc_chrdev_region()来申请8个设备号
	ret = alloc_chrdev_region(&dev, 0, MYDEMO_MAX_DEVICES, DEMO_NAME);
	if (ret) {
		printk("failed to allocate char device region");
		return ret;
	}
	//分配一个cdev的结构
	demo_cdev = cdev_alloc();
	if (!demo_cdev) {
		printk("cdev_alloc failed\n");
		goto unregister_chrdev;
	}
	//初始化demo_cdev并建立与驱动操作方法集的联系
	cdev_init(demo_cdev, &demodrv_fops);
    
	//将8个次设备号注册到系统中去
	ret = cdev_add(demo_cdev, dev, MYDEMO_MAX_DEVICES);
	if (ret) {
		printk("cdev_add failed\n");
		goto cdev_fail;
	}
	// 创建设备类
	mydemo_class = class_create(THIS_MODULE, "my_class");
    
 // 遍历8个设备并进行初始化
	for (i = 0; i < MYDEMO_MAX_DEVICES; i++) {
		device = kzalloc(sizeof(struct mydemo_device), GFP_KERNEL);// 分配设备结构体内存
		if (!device) {
			ret = -ENOMEM;
			goto free_device;
		}
 		// 格式化设备名称
		sprintf(device->name, "%s%d", DEMO_NAME, i);
        // 初始化互斥锁
		mutex_init(&device->lock);
		// 创建设备节点，初始化读写等待队列
		device->dev = device_create(mydemo_class, NULL, MKDEV(dev, i), NULL, "mydemo:%d:%d", MAJOR(dev), i);
		dev_info(device->dev, "create device: %d:%d\n", MAJOR(dev), MINOR(i));
		mydemo_device[i] = device;
		init_waitqueue_head(&device->read_queue);
		init_waitqueue_head(&device->write_queue);
		// 分配设备环形缓冲区
		ret = kfifo_alloc(&device->mydemo_fifo,MYDEMO_FIFO_SIZE,GFP_KERNEL);
		if (ret) {
			ret = -ENOMEM;
			goto free_kfifo;
		}

		printk("mydemo_fifo=%p\n", &device->mydemo_fifo);

	}

	printk("succeeded register char device: %s\n", DEMO_NAME);

	return 0;
    
//释放设备的 FIFO 缓冲区
free_kfifo:
	for (i =0; i < MYDEMO_MAX_DEVICES; i++)
		if (&device->mydemo_fifo)
			 kfifo_free(&device->mydemo_fifo);
// 释放设备结构体内存
free_device:
	for (i =0; i < MYDEMO_MAX_DEVICES; i++)
		if (mydemo_device[i])
			kfree(mydemo_device[i]);
cdev_fail:
	cdev_del(demo_cdev);// 删除 cdev 结构
unregister_chrdev:
	unregister_chrdev_region(dev, MYDEMO_MAX_DEVICES); // 注销设备号
	return ret;
}

static void __exit simple_char_exit(void)
{
	int i;
	printk("removing device\n");

	if (demo_cdev)
		cdev_del(demo_cdev);// 删除 cdev 结构

	unregister_chrdev_region(dev, MYDEMO_MAX_DEVICES);// 注销设备号
	// 遍历设备数组，如果设备存在，则销毁设备节点，释放设备结构体的空间
	for (i =0; i < MYDEMO_MAX_DEVICES; i++) {
		if (mydemo_device[i]) {
			device_destroy(mydemo_class, MKDEV(dev, i));
			kfree(mydemo_device[i]);	

		}
	}
	class_destroy(mydemo_class);// 销毁设备类
}

module_init(simple_char_init);
module_exit(simple_char_exit);

MODULE_AUTHOR("Benshushu");
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("simpe character device");
```

编译代码，并将其插入内核模块，则看到如下打印信息，会看到创建了 8 个设备，其中主设备号都为247。可以在/sys/class/my_class/即我们在代码中创建的设备类中查看设备信息。

<img src=".\img\interrupt_9.png"  style="zoom:67%;" />

<img src=".\img\interrupt_10.png"  style="zoom:67%;" />

但是在/dev目录下，我们打印信息，发现并没有主设备号为247的节点，因此这块需要手动创建。执行` mknod /dev/mydemo0 c 247 0`

<img src=".\img\interrupt_11.png"  style="zoom:67%;" />

### 5.1.3 用户态程序

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <errno.h>
#include <poll.h>
#include <signal.h>

static int fd;

// 定义异步通知的信号处理函数
void my_signal_fun(int signum, siginfo_t *siginfo, void *act)
{
    int ret;
    char buf[64];

    // 检查是否收到 SIGIO 信号
    if (signum == SIGIO) {
        // 检查是否有数据可读
        if (siginfo->si_band & POLLIN) {
            printf("FIFO is not empty\n");
            
            // 读取数据
            if ((ret = read(fd, buf, sizeof(buf))) != -1) {
                buf[ret] = '\0';
                puts(buf);
            }
        }
        
        // 检查是否有空间可写
        if (siginfo->si_band & POLLOUT)
            printf("FIFO is not full\n");
    }
}

int main(int argc, char *argv[])
{
    int ret;
    int flag;
    struct sigaction act, oldact;

    // 初始化信号处理函数
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGIO);
    act.sa_flags = SA_SIGINFO;
    act.sa_sigaction = my_signal_fun;

    // 注册 SIGIO 信号处理函数
    if (sigaction(SIGIO, &act, &oldact) == -1)
        goto fail;

    // 打开设备文件
    fd = open("/dev/mydemo0", O_RDWR);
    if (fd < 0) 
        goto fail;

    // 设置异步 I/O 所有权
    if (fcntl(fd, F_SETOWN, getpid()) == -1)
        goto fail;
    
    // 将当前进程 PID 设置为文件描述符所对应驱动程序将要发送 SIGIO, SIGUSR 信号的进程 PID
    if (fcntl(fd, F_SETSIG, SIGIO) == -1)
        goto fail;
    
    // 获取文件 flags
    if ((flag = fcntl(fd, F_GETFL)) == -1)
        goto fail;
    
    // 设置文件 flags，设置 FASYNC，支持异步通知
    if (fcntl(fd, F_SETFL, flag | FASYNC) == -1)
        goto fail;

    // 无限循环，等待异步通知
    while (1)
        sleep(1);

fail:
    perror("fasync test");
    exit(EXIT_FAILURE);
}

```

接下来编译和运行 test 程序，可以看到从 tasklet 的回调函数打印的一句话“do_tasklet: trigger a tasklet”。可以看到调用了tasklet的回调函数。

<img src=".\img\interrupt_12.png"  style="zoom:67%;" />

## 5.2 实验二、工作队列

### 5.2.1 实验内容

1）写一个简单的内核模块，初始化一个工作队列，在 write()函数里调用该工作

队列回调函数，在回调函数中输出用户程序写入的字符串。

2）写一个应用程序，测试该功能。

### 5.2.2 代码实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/init.h>
#include <linux/miscdevice.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/kfifo.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/cdev.h>
#include <linux/poll.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>

#define DEMO_NAME "mydemo_dev"
#define MYDEMO_FIFO_SIZE 64

// 定义字符设备号和结构体
static dev_t dev;
static struct cdev *demo_cdev;
static struct class *mydemo_class;

// 定义设备结构体
struct mydemo_device {
	char name[64];//设备名
	struct device *dev;//设备指针
    wait_queue_head_t read_queue;//读等待队列
	wait_queue_head_t write_queue;//写等待队列
	struct kfifo mydemo_fifo;//FIFO缓冲区
	struct fasync_struct *fasync;
	struct mutex lock;//锁
};

// 设备的私有数据结构体，里面添加了tasklet及工作队列
struct mydemo_private_data {
	struct mydemo_device *device;//设备指针，指向设备
	char name[64];	//设备名
	struct tasklet_struct tasklet;
    struct work_struct my_work;
};

#define MYDEMO_MAX_DEVICES  8//最多支持8个设备
static struct mydemo_device *mydemo_device[MYDEMO_MAX_DEVICES]; 

//tasklet 的回调函数
static void do_tasklet(unsigned long data)
{
	struct mydemo_device *device = (struct mydemo_device *)data;//通过强制转换来确保device指向了设备结构体

	dev_info(device->dev, "%s: trigger a tasklet\n", __func__);//打印相关信息
}
//工作队列中的工作的回调函数
static void do_work(struct work_struct *work)
{
	struct mydemo_private_data *data;
	struct mydemo_device *device;
    
	// 将 work 指针转换为包含该工作项的私有数据结构指针
	data = container_of(work, struct mydemo_private_data, my_work);	
	// 从私有数据结构中获取设备结构体的指针
	device = data->device;

	dev_info(device->dev, "%s: trigger a work\n", __func__);
}
//打开设备驱动的回调函数
static int demodrv_open(struct inode *inode, struct file *file)
{
	unsigned int minor = iminor(inode);//次设备号
	struct mydemo_private_data *data;
	struct mydemo_device *device = mydemo_device[minor];//device指向了次设备号对应的设备

	dev_info(device->dev, "%s: major=%d, minor=%d, device=%s\n", __func__, 
			MAJOR(inode->i_rdev), MINOR(inode->i_rdev), device->name);//打印相关信息

	data = kzalloc(sizeof(struct mydemo_private_data), GFP_KERNEL);//为保存设备的私有数据申请空间
	if (!data)
		return -ENOMEM;

	sprintf(data->name, "private_data_%d", minor);
    tasklet_init(&data->tasklet, do_tasklet, (unsigned long)device);//通过tasklet_init来初始化该设备的私有数据中的tasklet
	
	INIT_WORK(&data->my_work, do_work);//使用INIT_WORK来初始化工作队列，并将do_work函数与工作队列绑定

	// 将设备指针和私有数据指针关联
	data->device = device;
 	//将私有数据存储到file的private_data中
	file->private_data = data;
	return 0;
}
//释放设备驱动的回调函数
static int demodrv_release(struct inode *inode, struct file *file)
{
	struct mydemo_private_data *data = file->private_data;//data用来保存file结构的私有数据成员

	tasklet_kill(&data->tasklet);//调用tasklet_kill函数来关闭tasklet
	kfree(data);//释放空间
    
	return 0;
}


// 读取设备驱动的回调函数
static ssize_t
demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
   //file表示打开的设备文件，buf表示用户空间的内存起始地址,lbuf表示用户需要读取的字节数，ppos指向文件的位置
{
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备
	int actual_readed;//真实读取的字节数
	int ret;

	//如果设备驱动的KFIFO为空，且文件标志打开了非阻塞
	if (kfifo_is_empty(&device->mydemo_fifo)) {
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;
        
	//如果文件标志没有打开非阻塞，则让该进程进入睡眠，则打印睡眠进程的信息
		dev_info(device->dev, "%s:%s pid=%d, going to sleep, %s\n", __func__, device->name, current->pid, data->name);
        
        //使用wait_event_interruptible使得设备的读队列的队头元素进入可中断睡眠，直到环形缓冲区不为空
		ret = wait_event_interruptible(device->read_queue,!kfifo_is_empty(&device->mydemo_fifo));
		if (ret)
			return ret;
	}

	mutex_lock(&device->lock);//打开设备的互斥锁
    
    //读取数据这部分通过kfifo_to_user 函数将从KFIFO 中读取出count字节的数据复制到用户空间中去
	ret = kfifo_to_user(&device->mydemo_fifo, buf, count, &actual_readed);
	if (ret)
		return -EIO;
	
	mutex_unlock(&device->lock);//解锁
    
	//KFIFO有数据，则唤醒读队列中所有的可中断进程
	if (!kfifo_is_full(&device->mydemo_fifo)){
		wake_up_interruptible(&device->write_queue);
		kill_fasync(&device->fasync, SIGIO, POLL_OUT);
	}

	
	dev_info(device->dev, "%s:%s, pid=%d, actual_readed=%d, pos=%lld\n",__func__,
			device->name, current->pid, actual_readed, *ppos);//打印相关信息
	return actual_readed;
}

//写设备驱动的回调函数
static ssize_t
demodrv_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备

	unsigned int actual_write;
	int ret;
//如果环形缓冲区满了且文件标志打开了非阻塞标志
	if (kfifo_is_full(&device->mydemo_fifo)){
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;
//文件标志没有打开了非阻塞标志，则这个写操作进程进入睡眠状态
		dev_info(device->dev, "%s:%s pid=%d, going to sleep\n", __func__, device->name, current->pid);
		//使用wait_event_interruptible让设备的写队列的队头元素进入可中断睡眠，直到环形缓冲区不满
        ret = wait_event_interruptible(device->write_queue,
				!kfifo_is_full(&device->mydemo_fifo));
		if (ret)
			return ret;
	}

	mutex_lock(&device->lock);//打开设备的互斥锁
//kfifo _from user 函数将用户数据写入到 KFIFO 中，此时 actual_write 中保存的是实际写入成功的字节数
	ret = kfifo_from_user(&device->mydemo_fifo, buf, count, &actual_write);
	if (ret)
		return -EIO;
	schedule_work(&data->my_work);//将my_work这个工作添加到工作队列
	mutex_unlock(&device->lock);//解锁
    
//如果环形缓冲区中有空可写，则调用wake_up_interruptible来唤醒设备的写队列中的可中断睡眠的进程
	if (!kfifo_is_empty(&device->mydemo_fifo)) {
		wake_up_interruptible(&device->read_queue);
		kill_fasync(&device->fasync, SIGIO, POLL_IN);
		printk("%s kill fasync\n", __func__);
	}

	dev_info(device->dev, "%s:%s pid=%d, actual_write =%d, ppos=%lld, ret=%d\n", __func__,
			device->name, current->pid, actual_write, *ppos, ret);//打印相关信息

	return actual_write;
}

static unsigned int demodrv_poll(struct file *file, poll_table *wait)
{
	int mask = 0;
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备

	mutex_lock(&device->lock);//打开设备的互斥锁
//poll_ wait()函数会把当前进程添加到指定的等待列表 
	poll_wait(file, &device->read_queue, wait);
    poll_wait(file, &device->write_queue, wait);
 //如果缓冲区不空，唤醒写进程
	if (!kfifo_is_empty(&device->mydemo_fifo))
		mask |= POLLIN | POLLRDNORM;
    //如果缓冲区不满，唤醒读进程
	if (!kfifo_is_full(&device->mydemo_fifo))
		mask |= POLLOUT | POLLWRNORM;

	mutex_unlock(&device->lock);//解锁
	
	return mask;
}

static int demodrv_fasync(int fd, struct file *file, int on)
{
	struct mydemo_private_data *data = file->private_data;//data初始化为file结构的私有数据
	struct mydemo_device *device = data->device;//device指向设备

	int ret;

	mutex_lock(&device->lock);//打开设备的互斥锁

	dev_info(device->dev, "%s send SIGIO\n", __func__);//打印相关信息
	ret = fasync_helper(fd, file, on, &device->fasync); // 调用 fasync_helper 函数，处理异步通知
	mutex_unlock(&device->lock);//解锁

	return ret;
}
//定义了设备驱动的操作集
static const struct file_operations demodrv_fops = {
	.owner = THIS_MODULE,
	.open = demodrv_open,
	.release = demodrv_release,
	.read = demodrv_read,
	.write = demodrv_write,
        .poll = demodrv_poll,
	.fasync = demodrv_fasync,
};

//模块注册函数
static int __init simple_char_init(void)
{
	int ret;
	int i;
	struct mydemo_device *device;
	//通过alloc_chrdev_region()来申请8个设备号
	ret = alloc_chrdev_region(&dev, 0, MYDEMO_MAX_DEVICES, DEMO_NAME);
	if (ret) {
		printk("failed to allocate char device region");
		return ret;
	}
	//分配一个cdev的结构
	demo_cdev = cdev_alloc();
	if (!demo_cdev) {
		printk("cdev_alloc failed\n");
		goto unregister_chrdev;
	}
	//初始化demo_cdev并建立与驱动操作方法集的联系
	cdev_init(demo_cdev, &demodrv_fops);
    
	//将8个次设备号注册到系统中去
	ret = cdev_add(demo_cdev, dev, MYDEMO_MAX_DEVICES);
	if (ret) {
		printk("cdev_add failed\n");
		goto cdev_fail;
	}
	// 创建设备类
	mydemo_class = class_create(THIS_MODULE, "my_class");
    
 // 遍历8个设备并进行初始化
	for (i = 0; i < MYDEMO_MAX_DEVICES; i++) {
		device = kzalloc(sizeof(struct mydemo_device), GFP_KERNEL);// 分配设备结构体内存
		if (!device) {
			ret = -ENOMEM;
			goto free_device;
		}
 		// 格式化设备名称
		sprintf(device->name, "%s%d", DEMO_NAME, i);
        // 初始化互斥锁
		mutex_init(&device->lock);
		// 创建设备节点，初始化读写等待队列
		device->dev = device_create(mydemo_class, NULL, MKDEV(dev, i), NULL, "mydemo:%d:%d", MAJOR(dev), i);
		dev_info(device->dev, "create device: %d:%d\n", MAJOR(dev), MINOR(i));
		mydemo_device[i] = device;
		init_waitqueue_head(&device->read_queue);
		init_waitqueue_head(&device->write_queue);
		// 分配设备环形缓冲区
		ret = kfifo_alloc(&device->mydemo_fifo,MYDEMO_FIFO_SIZE,GFP_KERNEL);
		if (ret) {
			ret = -ENOMEM;
			goto free_kfifo;
		}

		printk("mydemo_fifo=%p\n", &device->mydemo_fifo);

	}

	printk("succeeded register char device: %s\n", DEMO_NAME);

	return 0;
    
//释放设备的 FIFO 缓冲区
free_kfifo:
	for (i =0; i < MYDEMO_MAX_DEVICES; i++)
		if (&device->mydemo_fifo)
			 kfifo_free(&device->mydemo_fifo);
// 释放设备结构体内存
free_device:
	for (i =0; i < MYDEMO_MAX_DEVICES; i++)
		if (mydemo_device[i])
			kfree(mydemo_device[i]);
cdev_fail:
	cdev_del(demo_cdev);// 删除 cdev 结构
unregister_chrdev:
	unregister_chrdev_region(dev, MYDEMO_MAX_DEVICES); // 注销设备号
	return ret;
}

static void __exit simple_char_exit(void)
{
	int i;
	printk("removing device\n");

	if (demo_cdev)
		cdev_del(demo_cdev);// 删除 cdev 结构

	unregister_chrdev_region(dev, MYDEMO_MAX_DEVICES);// 注销设备号
	// 遍历设备数组，如果设备存在，则销毁设备节点，释放设备结构体的空间
	for (i =0; i < MYDEMO_MAX_DEVICES; i++) {
		if (mydemo_device[i]) {
			device_destroy(mydemo_class, MKDEV(dev, i));
			kfree(mydemo_device[i]);	

		}
	}
	class_destroy(mydemo_class);// 销毁设备类
}
module_init(simple_char_init);
module_exit(simple_char_exit);

MODULE_AUTHOR("Benshushu");
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("simpe character device");
```

编译代码，并将其插入内核模块，则看到如下打印信息，会看到创建了 8 个设备，其中主设备号都为247。可以在/sys/class/my_class/即我们在代码中创建的设备类中查看设备信息。

<img src=".\img\interrupt_13.png"  style="zoom:67%;" />



<img src=".\img\interrupt_14.png"  style="zoom:67%;" />

创建节点之后，在/dev目录下可以查看到刚才创建的节点

<img src=".\img\interrupt_15.png"  style="zoom:67%;" />

### 5.2.3 用户态程序

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <errno.h>
#include <poll.h>
#include <signal.h>

static int fd;

// 信号处理函数
void my_signal_fun(int signum, siginfo_t *siginfo, void *act)
{
    int ret;
    char buf[64];

    // 检查是否收到 SIGIO 信号
    if (signum == SIGIO) {
        // 检查是否有数据可读
        if (siginfo->si_band & POLLIN) {
            printf("FIFO is not empty\n");
            
            // 读取数据
            if ((ret = read(fd, buf, sizeof(buf))) != -1) {
                buf[ret] = '\0';
                puts(buf);
            }
        }
        
        // 检查是否有空间可写
        if (siginfo->si_band & POLLOUT)
            printf("FIFO is not full\n");
    }
}

int main(int argc, char *argv[])
{
    int ret;
    int flag;
    struct sigaction act, oldact;

    // 初始化信号处理函数
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGIO);
    act.sa_flags = SA_SIGINFO;
    act.sa_sigaction = my_signal_fun;

    // 注册 SIGIO 信号处理函数
    if (sigaction(SIGIO, &act, &oldact) == -1)
        goto fail;

    // 打开设备文件
    fd = open("/dev/mydemo0", O_RDWR);
    if (fd < 0) 
        goto fail;

    // 设置异步 I/O 所有权
    if (fcntl(fd, F_SETOWN, getpid()) == -1)
        goto fail;
    
    // 将当前进程 PID 设置为文件描述符所对应驱动程序将要发送的信号的进程 PID
    if (fcntl(fd, F_SETSIG, SIGIO) == -1)
        goto fail;
    
    // 获取文件 flags
    if ((flag = fcntl(fd, F_GETFL)) == -1)
        goto fail;
    
    // 设置文件 flags，设置 FASYNC，支持异步通知
    if (fcntl(fd, F_SETFL, flag | FASYNC) == -1)
        goto fail;

    // 进入无限循环，等待异步通知
    while (1)
        sleep(1);

fail:
    perror("fasync test");
    exit(EXIT_FAILURE);
}
```



<img src=".\img\interrupt_16.png"  style="zoom:67%;" />

可以看到从 workqueue 的回调函数打印的一句话“do_work: trigger a work”。可以发现它成功使用了workqueue工作队列，并调用了do_work的函数。
